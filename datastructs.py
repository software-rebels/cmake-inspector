from typing import Optional, List
import copy

from condition_data_structure import Rule


class Node:
    created_commands = dict()

    def __init__(self, name: str, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if name in self.created_commands:
            self.created_commands[name] += 1
            self.name = "{}_{}".format(name, self.created_commands[name])
        else:
            self.created_commands[name] = 1
            self.name = name
        self.rawName = name
        self.parent: List[Optional[Node]] = []
        self.isVisited = False
        self.dbNode = None

    def getName(self):
        return self.name

    def getNodeName(self):
        return self.getName()

    def getChildren(self) -> Optional[List]:
        return []

    def getNeighbours(self):
        if self.getChildren():
            return self.getChildren() + self.parent
        return self.parent

    # Useful for some graph algorithms
    def addParent(self, node: "Node"):
        self.parent.append(node)

    def getValue(self):
        return None

    def __hash__(self):
        return hash(self.name)

    def __eq__(self, other):
        if other is None:
            return False
        return self.name == other.name


class TargetNode(Node):
    STATIC_LIBRARY = 'STATIC'
    SHARED_LIBRARY = 'SHARED'
    MODULE_LIBRARY = 'MODULE'

    def __init__(self, name: str, sources: Node):
        super().__init__(name)
        self.sources = sources  # Property of Target
        self.interfaceSources = None  # Property of Target
        self.compileFeatures = None  # Property of Target
        self.interfaceCompileFeatures = None  # Property of Target
        self.compileOptions = None  # Property of Target
        self.interfaceCompileOptions = None  # Property of Target
        self.includeDirectories = None  # Property of Target
        self.interfaceIncludeDirectories = None  # Property of Target
        self.interfaceSystemIncludeDirectories = None  # Property of Target
        self.definitions = None
        self.linkLibraries = None

        self.scope = None
        self.imported = False
        self.isAlias = False
        # This property indicates whether this is an executable or a library
        self.isExecutable = True
        # These properties are for libraries only
        self.libraryType = self.STATIC_LIBRARY
        self.isObjectLibrary = False
        self.interfaceLibrary = False
        # This property set for custom target only
        self.isCustomTarget = False
        # This property is for custom target indicating whether this target should compiled by
        # default or not
        self.defaultBuildTarget = False

        # This dictionary will keep track of the libraries that this target may depend on under different conditions
        # <CustomCommand (target_link_libraries command), condition: Set>
        self.linkLibrariesConditions = dict()

    def getPointTo(self) -> Node:
        return self.sources

    def getChildren(self):
        result = []
        if self.sources:
            result.append(self.sources)
        if self.definitions:
            result.append(self.definitions)
        if self.linkLibraries:
            result.append(self.linkLibraries)
        if self.interfaceSources:
            result.append(self.interfaceSources)
        if self.compileFeatures:
            result.append(self.compileFeatures)
        if self.interfaceCompileFeatures:
            result.append(self.interfaceCompileFeatures)
        if self.compileOptions:
            result.append(self.compileOptions)
        if self.interfaceCompileOptions:
            result.append(self.interfaceCompileOptions)
        if self.includeDirectories:
            result.append(self.includeDirectories)
        if self.interfaceIncludeDirectories:
            result.append(self.interfaceIncludeDirectories)
        if self.interfaceSystemIncludeDirectories:
            result.append(self.interfaceSystemIncludeDirectories)
        return result

    def addLinkLibrary(self, node: Node, autoGeneratedNumber):
        if self.linkLibraries and isinstance(self.linkLibraries, ConcatNode):
            self.linkLibraries.addToBeginning(node)
        else:
            concatNode = ConcatNode("{}_{}".format(self.getName(), autoGeneratedNumber))
            concatNode.addNode(node)
            if self.linkLibraries:
                concatNode.addNode(self.linkLibraries)
            self.linkLibraries = concatNode

    def setDefinition(self, node: Node):
        self.definitions = node

    def getDefinition(self):
        return self.definitions


class TestNode(Node):
    def __init__(self, name: str):
        super().__init__(name)
        self.command = None
        self.configurations = None
        self.working_directory = None

    def getChildren(self):
        result = [self.command]
        if self.configurations:
            result.append(self.configurations)
        if self.working_directory:
            result.append(self.working_directory)
        return result


class RefNode(Node):
    def __init__(self, name: str, pointTo: Optional[Node]):
        super().__init__(name)
        self.pointTo = pointTo
        self.relatedProperty = None

    def getPointTo(self) -> Node:
        return self.pointTo

    def getChildren(self):
        if self.pointTo:
            return [self.pointTo]
        return []

    def getValue(self):
        if self.getPointTo():
            return self.pointTo.getName()
        return self.getName()[:self.getName().rindex('_')]


class OptionNode(Node):
    def __init__(self, name: str):
        super().__init__(name)
        self.depends: Optional[Node] = None
        self.description: Optional[str] = None
        self.default: bool = False
        self.dependentOption: Optional[bool] = False

    def getPointTo(self) -> Node:
        return self.depends

    def getChildren(self):
        if self.depends:
            return [self.depends]
        return []

    def getValue(self):
        return self.getName()


# TODO: Use polymorphism here to implement CMake commands instead of handling all of them in evaluate function
class CustomCommandNode(Node):
    def __init__(self, name: str):
        super().__init__(name)
        self.commands: List[Node] = []
        self.depends: List[Node] = []
        # For backward compatibility
        self.pointTo = self.commands
        self.extraInfo = {}

    def getChildren(self) -> Optional[List]:
        result = []
        if self.commands:
            result += self.commands
        if self.depends:
            result += self.depends
        if result:
            return result
        return None

    def evaluate(self, conditions, recStack, lookup=None):
        raise Exception('Deprecated')


class ConcatNode(Node):
    def __init__(self, name: str):
        super().__init__(name)
        self.listOfNodes = list()
        self.concatString = False

    def getNodeName(self):
        return "CONCAT"

    def addNode(self, node: Node):
        self.listOfNodes.append(node)

    def addToBeginning(self, node: Node):
        self.listOfNodes.insert(0, node)

    def getNodes(self) -> List[Node]:
        return self.listOfNodes

    def getChildren(self):
        return self.getNodes()

    def getValue(self):
        result = []
        for child in self.getChildren():
            result.append(str(child.getValue()))
        if self.concatString:
            return "".join(result)
        else:
            return " ".join(result)


class LiteralNode(Node):
    def __init__(self, name, value=""):
        super().__init__(name)
        self.value = value

    def setValue(self, value):
        self.value = value

    def getValue(self):
        return self.value


class SelectNode(Node):
    rule: Rule = None

    def __init__(self, name, condition):
        super().__init__(name)
        self.trueNode: Optional[Node] = None
        self.falseNode: Optional[Node] = None
        self.conditionList = copy.deepcopy(condition)
        self.condition = " ".join(condition)
        self.args = None

    def getNodeName(self):
        return "SELECT\n" + self.rule.getCondition().getText(pretty=True)

    def setTrueNode(self, node: Node):
        self.trueNode = node

    def setFalseNode(self, node: Node):
        self.falseNode = node

    def getChildren(self):
        result = list()
        if self.trueNode:
            result.append(self.trueNode)
        if self.falseNode:
            result.append(self.falseNode)
        if self.args:
            result.append(self.args)
        return result


class Lookup:
    _instance = None

    def __init__(self):
        self.items = [{}]
        self.variableHistory = {}

    def newScope(self):
        self.items.append({})

    def setKey(self, key, value, parentScope=False):
        if key not in self.variableHistory:
            self.variableHistory[key] = []

        self.variableHistory[key].append(value)
        if parentScope:
            self.items[-2][key] = value
        else:
            self.items[-1][key] = value

    def getKey(self, key) -> Optional[RefNode]:
        for table in reversed(self.items):
            if key in table:
                return table.get(key)
        return None

    def getOwnKey(self, key) -> Optional[Node]:
        lastTable = self.items[-1]
        return lastTable.get(key, None)

    def getVariableHistory(self, key) -> List[RefNode]:
        return self.variableHistory[key]

    def deleteKey(self, key, parentScope=False):
        if parentScope:
            del (self.items[-2][key])
        else:
            del (self.items[-1][key])

    def dropScope(self):
        self.items.pop()

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.items = []
        for item in self.items:
            result.items.append(dict.copy(item))
        return result

    @classmethod
    def getInstance(cls):
        if cls._instance is None:
            cls._instance = Lookup()

        return cls._instance

    @classmethod
    def clearInstance(cls):
        cls._instance = None
