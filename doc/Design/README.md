# Design Decisions
In this section, we talk about different tech stack we use in DiPiDi tool.

## Parse CMake files
First, we read the `cmakelists.txt` file in the root directory, which is the entry point
for CMake projects. Then, we parse the file and include other CMake related files and 
subdirectory. After that, we build the AST and turn it into a build dependency graph. Finally,
we use the generated graph to traverse each compilation path, and use a satisfiability modulo 
theories solver to prune unreachable paths.

### Build AST
We use [ANTLR V4](https://github.com/antlr/antlr4) to parse and build the AST. You can find the
grammar we write for CMake [here](../../grammar/CMake.g4).

### Build Dependency Graph
We have the following nodes in the graph:
- **TargetNode**: Shows an executable or a library generated by `add_executable` or `add_library`
command.
- **RefNode**: Represents a variable and points to a value corresponding to that variable. There
could be multiple `RefNode` for a variable. This feature allows us to track the history and changes
for a specific variable.
- **OptionNode**: Shows options generated by `option` command.
- **ConcatNode**: This node represents concatenation and mostly show lists or multiple dependency.
- **LiteralNode**: This node can show a string or a number.
- **SelectNode**: Represents the condition in the compilation path generated by the `if` command.
This node has two children which point to the `true` and `false` path.
- **CustomCommandNode**: Other commands like `while, foreach, add_definitions, etc.` may have different number of
arguments and may depend on a variable which may have different values under different configurations. We create a
`CustomCommandNode` for these commands and postponed their execution to the evaluation phase.